# 自定义标签解析

## 自定义标签使用
很多情况下，需要为系统提供可配置化支持，简单做法可以直接基于Spring的标准bean来配置，但配置较为复杂或者需要更多丰富控制的时候，会变得很难配置。
一般可以自己解析定义好的XML文件，然后转化为配置对象，这种方式可以解决问题但实现起来比较复杂。Spring提供了可扩展Schema的支持，扩展Spring
自定义标签配置大致需要以下几步

- 创建一个需要扩展的组件

- 定义一个XSD文件描述组件内容

- 创建一个文件，实现BeanDefinitionParser接口，用来解析XSD文件中的定义和组件定义

- 创建一个Handler文件，扩展自NamespaceHandlerSupport，目的是将组件注册到Spring容器

- 编写Spring.handles和Spring.schemas文件

具体操作如下

(1) 首先创建一个普通POJO
```
package org.aim.spring.lookup_method;

public class User {
    private String userName;
    private String email;

    public void showMe(){
        System.out.println("I am user");
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

(2) 定义一个XSD文件描述组件内容
```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.aim.org/schema/user"
        xmlns:tns="http://www.aim.org/schema/user"
        elementFormDefault="qualified">
    <element name="user">
        <complexType>
            <attribute name="id" type="string" />
            <attribute name="userName" type="string" />
            <attribute name="email" type="string" />
        </complexType>
    </element>
</schema>
```
XSD文件中描述了一个新的targetNamespace，并在这个空间中定义一个name为user的element，user有三个属性id、userName和email，email类型为
string

(3) 创建一个文件，实现BeanDefinitionParser接口，用来解析XSD文件中的定义和组件定义

```
package org.aim.spring.custom;

import org.aim.spring.lookup_method.User;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

public class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {

    // Element对应的类
    @Override
    protected Class<?> getBeanClass(Element element) {
        return User.class;
    }

    // 从element中解析并提取对应的元素
    @Override
    protected void doParse(Element element, BeanDefinitionBuilder builder) {
        String userName = element.getAttribute("userName");
        String email = element.getAttribute("email");
        // 将提取的数据放入BeanDefinitionBuilder中，待所有bean解析完成后统一组册到beanFactory
        if(StringUtils.hasText(userName)){
            builder.addPropertyValue("userName", userName);
        }
        if(StringUtils.hasText(email)){
            builder.addPropertyValue("email", email);
        }
    }
}
```

(4) 创建一个Handler文件，扩展自NamespaceHandlerSupport,目的是将组件注册到Spring容器。以下代码当遇到自定义标签<user:aaa这样类似于以
user开头的元素，就会把这个元素交由UserBeanDefinitionParser去解析
```
package org.aim.spring.custom;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {
    @Override
    public void init() {
        registerBeanDefinitionParser("user", new UserBeanDefinitionParser());
    }
}
```

(5) 编写Spring.handlers和Spring.schemas文件，默认位置是在工程的/META-INF/文件夹下，也可以通过Spring的扩展或修改源码的方式改变路径
```
// Spring.handlers
http\://www.aim.org/schema/user=org.aim.spring.custom.MyNamespaceHandler

// Spring.schemas
http\://www.lexueba.com/schema/user.xsd=user.xsd
```

自定义配置到这里就完成了，Spring加载自定义的大致流程是遇到自定义标签后通过Spring.handlers和Spring.schemas中找对应的handler和XSD，默认
位置是/META-INF/下，进而找到handler及解析元素的Parser，完成整个自定义元素的解析。自定义标签与Spring默认的标准标签不同在于，自定义标签
将解析的工作交给用户去实现

(6) 创建测试配置文件，在配置文件中引入对应的命名空间及XSD后，便可以直接使用自定义标签
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:myname="http://www.aim.org/schema/user"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd http://www.aim.org/schema/user http://www.aim.org/schema/user.xsd">

    <myname:user id="testbean" userName="aaa" email="bbb"></myname:user>

</beans>
```

(7) 测试通过自定义标签获取Bean
```
@Test
public void customTagTest(){
    ApplicationContext bf = new ClassPathXmlApplicationContext("CustomTagTest.xml");
    User user = (User) bf.getBean("testbean");
    System.out.println(user.getUserName() + "," + user.getEmail());
}
```

## 自定义标签解析
我们来看一下自定义标签的解析过程
```
public BeanDefinition parseCustomElement(Element ele) {
    return parseCustomElement(ele, null);
}

// containingBd是父类bean，对顶层元素的解析设置为null
public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {
    // 获取对应的命名空间
    String namespaceUri = getNamespaceURI(ele);
    // 根据命名空间找到对应的NamespaceHandler
    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    if (handler == null) {
        error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
        return null;
    }
    // 调用自定义的NamespaceHandler进行解析
    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
}
```
其实现思路是先根据对应bean获取对应的命名空间，根据命名空间获取对应的处理器，调用用户自定义的处理器完成解析

### 获取标签的命名空间
标签的解析是从命名空间的提取开始的，无论是区分Spring默认标签和自定义标签还是区分自定义标签中不同标签的处理器都是以标签所提供的命名空间为
基础的，提取对应元素的命名空间并不需要我们自己实现，在org.w3c.dom.Node中已经提供方法
```
public String getNamespaceURI(Node node) {
    return node.getNamespaceURI();
}
```

### 提取自定义标签处理器
获取命名空间后，就可以进行NamespaceHandler提取了。在readerContext初始化的时候其属性namespaceHandlerResolver已经被初始化为DefaultNamespaceHandlerResolver
的实例，因此调用resolve方法其实调用的是DefaultNamespaceHandlerResolver中的方法，在DefaultNamespaceHandlerResolver中resolve方法
如下
```
public NamespaceHandler resolve(String namespaceUri) {
    // 获取所有已经配置的handler映射
    Map<String, Object> handlerMappings = getHandlerMappings();
    // 根据命名空间找到对应的handler信息
    Object handlerOrClassName = handlerMappings.get(namespaceUri);
    if (handlerOrClassName == null) {
        return null;
    }
    else if (handlerOrClassName instanceof NamespaceHandler) {
        // 已经解析过直接返回
        return (NamespaceHandler) handlerOrClassName;
    }
    else {
        // 没做过解析返回的是类路径字符串
        String className = (String) handlerOrClassName;
        try {
            // 通过反射根据类路径加载类
            Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);
            if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {
                throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri +
                        "] does not implement the [" + NamespaceHandler.class.getName() + "] interface");
            }
            // 实例化bean
            NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
            // 调用自定义解析handler的初始化方法
            namespaceHandler.init();
            // 记录在缓存中
            handlerMappings.put(namespaceUri, namespaceHandler);
            return namespaceHandler;
        }
        catch (ClassNotFoundException ex) {
            throw new FatalBeanException("NamespaceHandler class [" + className + "] for namespace [" +
                    namespaceUri + "] not found", ex);
        }
        catch (LinkageError err) {
            throw new FatalBeanException("Invalid NamespaceHandler class [" + className + "] for namespace [" +
                    namespaceUri + "]: problem with handler class file or dependent class", err);
        }
    }
}
```

Spring.handlers文件中配置了命名空间与命名空间处理器的映射关系。只有正确维护了此文件，Spring才能根据映射关系找到匹配的处理器，上面分析的
方法就是用于寻找处理，当获取到用户自定义的handler实现，后调用init方法执行BeanDefinitionParser注册。在这里可以注册多个标签解析器，如
<myname:A、<myname:B等，这里只支持<myname:user。

注册后，命名空间解析器就可以根据不同的标签调用不同的解析器实现解析。getHandlerMappings主要功能就是读取Spring.handlers配置文件并将配置
文件缓存在map中
```
private Map<String, Object> getHandlerMappings() {
    // 如果缓存中不存在，则解析并放入缓存
    if (this.handlerMappings == null) {
        synchronized (this) {
            if (this.handlerMappings == null) {
                try {
                    // this.handlerMappingsLocation 在构造函数中已经被初始化为：META-INF/Spring.handlers
                    Properties mappings =
                            PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);
                    if (logger.isDebugEnabled()) {
                        logger.debug("Loaded NamespaceHandler mappings: " + mappings);
                    }
                    Map<String, Object> handlerMappings = new ConcurrentHashMap<String, Object>(mappings.size());
                    // 将Properties格式合并到Map中
                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);
                    this.handlerMappings = handlerMappings;
                }
                catch (IOException ex) {
                    throw new IllegalStateException(
                            "Unable to load NamespaceHandler mappings from location [" + this.handlerMappingsLocation + "]", ex);
                }
            }
        }
    }
    return this.handlerMappings;
}
```
借助工具类PropertiesLoaderUtils对属性handlerMappingsLocation进行配置文件读取，handlerMappingsLocation默认初始化为META-INF/spring.handlers

### 标签解析
获取到解析器以及要分析的元素后，Spring就可以将解析工作委托给自定义解析器去解析。此时handler已经被实例化为自定义MyNamespaceHandler，并
完成了初始化操作，但我们并没有在自定义命名空间中实现parse方法，这个方法是在父类中实现，查看父类NamespaceHandlerSupport中的parse方法
```
public BeanDefinition parse(Element element, ParserContext parserContext) {
    return findParserForElement(element, parserContext).parse(element, parserContext);
}
```
解析过程中首先寻找元素对应的解析器，进而调用解析器的parse方法，在本例中首先获取MyNameSpaceHandler类中的init方法中注册的对应的UserBeanDefinitionParser实例，
并调用其parse方法进行进一步解析
```
private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
    // 获取元素名称，在本例中就是<myname:user 中的user
    String localName = parserContext.getDelegate().getLocalName(element);
    // 根据user找到对应的解析器，即registerBeanDefinitionParser("user", new UserBeanDefinitionParser());中注册的解析器
    BeanDefinitionParser parser = this.parsers.get(localName);
    if (parser == null) {
        parserContext.getReaderContext().fatal(
                "Cannot locate BeanDefinitionParser for element [" + localName + "]", element);
    }
    return parser;
}
```
对于parse方法的处理
```
public final BeanDefinition parse(Element element, ParserContext parserContext) {
    AbstractBeanDefinition definition = parseInternal(element, parserContext);
    if (definition != null && !parserContext.isNested()) {
        try {
            String id = resolveId(element, definition, parserContext);
            if (!StringUtils.hasText(id)) {
                parserContext.getReaderContext().error(
                        "Id is required for element '" + parserContext.getDelegate().getLocalName(element)
                                + "' when used as a top-level tag", element);
            }
            String[] aliases = new String[0];
            String name = element.getAttribute(NAME_ATTRIBUTE);
            if (StringUtils.hasLength(name)) {
                aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));
            }
            // 将AbstractBeanDefinition转换成BeanDefinitionHolder
            BeanDefinitionHolder holder = new BeanDefinitionHolder(definition, id, aliases);
            registerBeanDefinition(holder, parserContext.getRegistry());
            if (shouldFireEvents()) {
                // 通知监听器进行处理
                BeanComponentDefinition componentDefinition = new BeanComponentDefinition(holder);
                // 可继承覆盖
                postProcessComponentDefinition(componentDefinition);
                parserContext.registerComponent(componentDefinition);
            }
        }
        catch (BeanDefinitionStoreException ex) {
            parserContext.getReaderContext().error(ex.getMessage(), element);
            return null;
        }
    }
    return definition;
}
```
上述方法中大部分代码是用来处理解析后的AbstractBeanDefinition转化为BeanDefinitionHolder并注册的功能，真正解析的操作是委托给了parseInternal
方法，在此方法中就调用了我们自定义的解析函数

在parseInternal中并没有直接调用doParse函数，而是先进行一系列数据准备，包括对beanClass、scope、lazyInit等属性的准备
```
@Override
protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();
    String parentName = getParentName(element);
    if (parentName != null) {
        builder.getRawBeanDefinition().setParentName(parentName);
    }
    // 获取自定义标签中class，此时会调用自定义解析器UserBeanDefinitionParser中的getBeanClass方法
    Class<?> beanClass = getBeanClass(element);
    if (beanClass != null) {
        builder.getRawBeanDefinition().setBeanClass(beanClass);
    }
    else {
        // 若子类没有重写getBeanClass方法则尝试检查子类是否重写getBeanClassName方法
        String beanClassName = getBeanClassName(element);
        if (beanClassName != null) {
            builder.getRawBeanDefinition().setBeanClassName(beanClassName);
        }
    }
    builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));
    if (parserContext.isNested()) {
        // 若存在父类，则使用父类的scope属性
        builder.setScope(parserContext.getContainingBeanDefinition().getScope());
    }
    if (parserContext.isDefaultLazyInit()) {
        // 配置延迟加载
        builder.setLazyInit(true);
    }
    // 调用子类重写的doParse方法进行解析
    doParse(element, parserContext, builder);
    return builder.getBeanDefinition();
}
```

虽然在实例中我们定义UserBeanDefinitionParser，但我们只做了与自己业务逻辑相关的部分。其实在这个过程中同样也是按照Spring中默认标签的处理
方式进行，包括创建BeanDefinition以及进行相应默认属性的设置，对于这些工作Spring都默认帮我们实现了，只是暴露一些接口来供用户实现个性化业务。
